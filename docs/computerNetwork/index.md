## 1. 计算机网络体系结构

计算机网络体系结构分为 3 种：

- **OSI 体系结构**
  - 概念清楚 & 理念完整，但复杂 & 不实用
- **`TCP/IP`体系结构**
  - 含了一系列构成互联网基础的网络协议，是 Internet 的核心协议，被广泛应用于局域网和广域网
- **五层体系结构**
  - 融合了 OSI 与 TCP/IP 的体系结构

![计算机网络体系结构](@/network/networkSystem.png)

### 1.1. TCP/IP 体系结构

1. **网路接口层**
   - 负责与链路（传输媒介）的数据传输工作
2. **网际层**
   - 为分组交换网上的不同主机提供通信服务
   - IP 协议：提供网络结点之间的报文传送服务，负责计算机之间的通信
3. **运输层**
   - 为不同主机进程之间提供通信服务
   - TCP 协议：提供用户间面向连接、可靠的报文传输服务
   - UDP 协议：提供用户间无连接、不可靠的报文传输服务
4. **应用层**
   - 定义应用进程间通信&交互的规则
   - HTTP 协议：提供 Internet 网浏览服务（基于 TCP）
   - FTP 协议：提供应用级文件传输服务（基于 TCP）
   - DNS 协议：负责域名和 IP 地址的映射（基于 UDP）
   - SMB 协议：提供应用级文件共享传输服务
   - SSH 协议：提供远程登录服务（加密）

![TCP/IP](@/network/tcpip.png)

## 2. TCP 协议

Transmission Control Protocol，即传输控制协议

- 属于运输层通信协议
- 基于 TCP 的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet`和`POP3`

### 2.1. TCP 三次握手

所谓三次握手（Three-Way Handshake）即建立 TCP 连接，就是指建立一个 TCP 连接时，需要客户端和服务端总共发送 3 个包以确认连接的建立。

1. 第一次握手：Client 将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给 Server，Client 进入 SYN_SENT 状态，等待 Server 确认。

2. 第二次握手：Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。

3. 第三次握手：Client 收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给 Server，Server 检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。

![tcpConnect](@/network/tcpConnect.png)

### 2.2. TCP 四次挥手

所谓四次挥手（Four-Way Wavehand）即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。

由于 TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

1. 第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。

2. 第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。

3. 第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。

4. 第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手。

![tcpDisConnect](@/network/tcpDisConnect.png)

### 2.3. 为什么结束连接是四次挥手

1. 当主机 A 确认发送完数据且知道 B 已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发 FIN 给主机 B。
2. 主机 B 收到 A 发送的 FIN，表示收到了，就会发送 ACK 回复。
3. 但这是 B 可能还在发送数据，没有想要关闭数据口的意思，所以 FIN 与 ACK 不是同时发送的，而是等到 B 数据发送完了，才会发送 FIN 给主机 A。
4. A 收到 B 发来的 FIN，知道 B 的数据也发送完了，回复 ACK， A 等待 2MSL 以后，没有收到 B 传来的任何消息，知道 B 已经收到自己的 ACK 了，A 就关闭链接，B 也关闭链接了。

**网上转载的例子不错：**

**三次握手：**

> A:“喂，你听得到吗？”A->SYN_SEND <br>
> B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B->SYN_RCVD | A->ESTABLISHED<br>
> A:“我能听到你，今天 balabala……”B->ESTABLISHED

**四次挥手：**

> A:“喂，我不说了。”A->FIN_WAIT1<br>
> B:“我知道了。等下，上一句还没说完。Balabala…..”B->CLOSE_WAIT | A->FIN_WAIT2<br>
> B:”好了，说完了，我也不说了。”B->LAST_ACK<br>
> A:”我知道了。”A->TIME_WAIT | B->CLOSED<br>
> A 等待 2MSL,保证 B 收到了消息,否则重说一次”我知道了”,A->CLOSED

**为什么等待 2MSL，从 TIME_WAIT 到 CLOSE？**

在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

## 3. UDP 协议

User Datagram Protocol，即用户数据报协议

- 属于运输层通信协议
- 基于 UDP 的应用层协议有`TFTP`、`SNMP`与`DNS`

**特点**

- 无连接的，不需要建立 UDP 连接
- 不可靠的，UDP 的数据包发送后，不管是否到达接收方
- 面向报文，数据以数据报文形式传输
- 无拥塞控制，由于是不可靠传输，即不管是否到达接收方，故不需要拥塞控制

**优缺点**

- 优点：速度快
- 缺点：消息易丢失（特别是网络较差时）

## 4. HTTP 协议

HTTP（Hyper Text Transfer Protocol）超文本传输协议缩写，是浏览器与服务端之间最主要的通信协议。
HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。

### 4.1. HTTP 发展史

#### 4.1.1. HTTP0.9

- 1991 年发布 0.9 版本，**只支持 GET 请求**
- 仅支持 HTML 格式
- 不支持长连接，当客户端和服务端通信完后就会关闭连接，一次连接一个请求

#### 4.1.2. HTTP1.0

- 支持更多文件格式，比如图片、视频、二进制文件，使网页内容更加丰富
- 新增 POST、HEAD 方法
- **增加了报头信息（HTTP header）**、状态码、缓存、权限等功能
- 不支持长连接

其中最核心的改变是增加了头部设定，头部内容以键值对的形式设置。请求头部通过 Accept 字段来告诉服务端可以接收的文件类型，响应头部再通过 Content-Type 字段来告诉浏览器返回文件的类型。

头部字段不仅用于解决不同类型文件传输的问题，也可以实现其他很多功能如缓存、认证信息等。

#### 4.1.3. HTTP1.1

- **支持长连接**，一个连接可以发送多次请求，并且支持一个连接同时发送多个请求（响应的顺序必须和请求的顺序一致，可能会出现某个请求获取较慢阻塞后面请求数据返回）
- 新增 PUT PATCH DELET OPTIONS 方法
- 新增了一些缓存的字段（If-Modified-Since, If-None-Match）
- 请求头中引入了 range 字段，支持断点续传
- 允许响应数据分块（chunked），利于传输大文件
- 请求头信息增加 Host 字段，指定服务器的域名，让互联网主机托管成为可能，这样服务器上支持了虚拟机，即一台机器多个站点

HTTP/1.1 与 HTTP/1.0 的一个重要区别是：
**HTTP/1.1 是一个“正式的标准”**

#### 4.1.4. HTTP2.0

- HTTP/2 支持了在一个连接里，客户端和服务端同时发送多个请求
- 允许服务器主动向客户推送数据
- 多路复用功能，同一连接多个请求不再按照顺序来
- 支持报头压缩
- 所有数据二进制传输
- 因为支持了在一个连接里同时发送多个请求和多个回应，为了区分它们就需要对数据做标记，每个请求或回应的所有数据包为一个数据流（stream），每个数据流都有一个唯一的 ID，客户端发送的请求 ID 为奇数，服务端返回的为偶数

HTTP/1.1 通过长连接减少了大量创建/断开连接造成的性能消耗，但是它的并发能力受到限制，表现在两个方面：

- HTTP/1.1 中使用持久连接时，一个连接中同一时刻只能处理一个请求。当前的请求没有结束之前，其他的请求只能处于阻塞状态，这种情况被称为「队头阻塞」
- 浏览器为了减轻服务器的压力，限制了同一个域名下的 HTTP 连接数，即 6 ~ 8 个

### 4.2. HTTPS

- 安全超文本传输协议（Hyper Text Transfer Protocol Secure）
- 数据加密传输
  - 防止各种攻击手段（信息泄露、篡改等）
- SSL/TSL（Secure Socket Layer/Transport Layer Secure）
  - SSL-安全套接层
  - TSL-传输层安全性协议
  - 需要在客户端安装证书

#### 4.2.1. HTTPS 请求过程（一次 HTTPS 请求要进行两次 HTTP 传输）

1. 客户端发出 https 请求，请求服务端建立 SSL 连接；
2. 服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端；
3. 客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥；
4. 客户端将公钥与客户端私钥进行对称加密后传给服务端；
5. 服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥；
6. 服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端；
7. 客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容。

#### 4.2.2. 为什么 HTTPS 很安全却不普及？

1. 加密通信与普通的文本通信，要消耗更多的 CPU 和内存，缓存慢，通信成本较大；
2. HTTPS 通信需要证书，而证书不是免费的

### 4.3. 常见 HTTP 状态码

- **1xx：信息，服务器收到请求，需要请求者继续执行操作**

  - 100 Continue 继续。客户端应继续其请求
  - 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议

- **2xx: 成功，操作被成功接收并处理**

  - 200 OK 请求成功。一般用于 GET 与 POST 请求
  - 201 Created 已创建。成功请求并创建了新的资源
  - 202 Accepted 已接受。已经接受请求，但未处理完成
  - 203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本
  - **204** No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
  - **205** Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
  - **206** Partial Content 部分内容。服务器成功处理了部分 GET 请求

- **3xx: 重定向，需要进一步的操作以完成请求**

  - 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
  - **301** Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替
  - **302** Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI
  - 303 See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看
  - **304** Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
  - 305 Use Proxy 使用代理。所请求的资源必须通过代理访问
  - 306 Unused 已经被废弃的 HTTP 状态码
  - 307 Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向

- **4xx: 客户端错误，请求包含语法错误或无法完成请求**
  - 400 Bad Request 客户端请求的语法错误，服务器无法理解
  - **401** Unauthorized 请求要求用户的身份认证
  - 402 Payment Required 支付相关，保留，将来使用
  - **403** Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
  - **404** Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
  - 405 Method Not Allowed 客户端请求中的方法被禁止
  - 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求
  - 407 Proxy Authentication Required 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权
  - 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时
  - 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突
  - 410 Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置
  - 411 Length Required 服务器无法处理客户端发送的不带 Content-Length 的请求信息
  - 412 Precondition Failed 客户端请求信息的先决条件错误
  - 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息
  - 414 Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理
  - 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式
  - 416 Requested range not satisfiable 客户端请求的范围无效
  - 417 Expectation Failed 服务器无法满足 Expect 的请求头信息
- **5xx: 服务端错误，服务器在处理请求的过程中发生了错误**
  - **500** Internal Server Error 服务器内部错误，无法完成请求
  - 501 Not Implemented 服务器不支持请求的功能，无法完成请求
  - **502** Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  - **503** Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中
  - **504** Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求
  - 505 HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理
